## 前言  
我们都会对项目进行分层，如常见的n层设计，分层的目的是让代码逻辑更加清晰，各层次各司其职，提升代码的可维护性。如常见的分层：controller -> service -> mapper。实际开发过程中，还会涉及到缓存读写，接口调用等。一个好的层次需要具备以下特点：
- 易于开发和维护，容易上手
- 各层职责清晰，聚合度高
- 分层效果能让整个团队都接受

## 阿里分层规范
阿里推荐的分层如下：  
![image](https://github.com/jmilktea/jmilktea/blob/master/%E8%AE%BE%E8%AE%A1/images/frm-1.png)  
我们看各个层次的作用：
- 开放接口层  
可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行 网关安全控制、流量控制等。
- 终端显示层  
各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。
- Web层  
主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。
- Service层  
相对具体的业务逻辑服务层。
- Manager层  
通用业务处理层，它有如下特征:
1) 对第三方平台封装的层，预处理返回结果及转化异常信息;
2) 对Service层通用能力的下沉，如缓存方案、中间件通用处理;
3) 与DAO层交互，对多个DAO的组合复用。
- DAO层   
数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。
- 外部接口或第三方平台  
包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。

参考:https://z201.cn/2019/05/27/%E6%80%BB%E7%BB%93%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/  
现在的项目通常是前后端分离，我们不关注终端显示层和web层  

## 事务问题
我们使用spring声明式事务@Transactional注解，其原理是通过aop进行around，即在标记方法开始前开启事务，方法执行后提交事务。如果方法内还有一些其它逻辑，如参数校验，外部接口调用，缓存查询等，该事务就会很长，加锁的时间就会很长，降低数据库的并发性。实际就是事务粒度问题，原则上事务方法内应该只处理事务，不允许处理其它逻辑。

## 分层设计  
我们推荐抽一层XXXDbService，专门用于数据库的操作，主要是定义事务，这里不包含业务逻辑也不能做任何耗时操作     
而XXXService是业务service，用于聚合业务，实际逻辑处理，这里不能直接访问数据库  
这里带来一个问题是，如果只是简单的查询，将会多一层的调用，由service->mapper变成service->dbservice->mapper  
![image](https://github.com/jmilktea/jmilktea/blob/master/%E8%AE%BE%E8%AE%A1/images/frm-3.png)





