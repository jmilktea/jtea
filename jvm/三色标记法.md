java语言的一个特点就是自动内存管理，不像c/c++需要手动申请释放内存，java可以专注在代码逻辑上，而不用管底层的内存管理问题，也避免了程序员申请后忘记释放出现的内存泄漏问题，这一切都归功于java虚拟机，这也是jvm的一个核心功能，垃圾回收，也就是我们常说的GC。   

随着程序的运行，越来越多的对象被创建，内存占用也越来越大，但许多对象使用完就不再存活了，对应的内存应该被释放，腾出空间给后面创建的对象使用。垃圾回收的目的就回收掉不再存活对象的内存，而判断一个对象是否还存活，主要有两种方式：   

- 引用计数法    
引用技术法的思想是为每个对象维护一个引用计数，当引用关系建立时，计数+1，当引用关系解除时，计数-1。   
这种方式的问题是，需要为每个对象维护一个计数，会占用一部分空间，且每次建立/解除关系时需要操作计数。但最主要的问题是存在复杂的相互引用的问题，如a.b引用了b对象，b.a引用了a对象，他们之间就存在相互依赖，假如a,b实际没被使用了，但它们的引用技术依然是1。python就采用了这种方式，要解决这个问题比较麻烦，付出的代价比较高，所以主流的java虚拟机都没有采用这种方式。    

- 可达性分析   
可达性分析也称为根搜索算法，是从一组称为**gc roots**的根对象出发，根据引用关系，遍历整个对象引用图，当一个对象直接或间接被gc roots引用着，就表示它还存活，否则需要被回收，目前所有主流的java虚拟机都采用这种方式。   

那么哪些对象可以作为gc roots呢？常见的有以下几种：   
1. Class，由系统类加载器加载的类型对象，这些对象不会被卸载，它们所持有的静态字段（存放在堆中，静态属性所引用的对象）  
2. 常量池中的对象(存放在堆中的字符串常量池)    
3. Thread，存活的线程   
4. Stack Local，线程栈中的引用对象    
5. 本地方法栈中的引用对象   
6. 同步锁对象    

从gc roots出发，遍历整个引用链，最简单做法就是在标记存活对象期间进行Stop The World，也就是暂停用户线程的执行，这样做的目的是避免在标识过程中又产生新的垃圾，或者改变引用关系，把没被标识的垃圾对象有重新赋值到存活的对象，这样就乱套了，这种做法的好处是简单，可以准确标识出存活对象，回收垃圾对象。但缺点也很明显，就是整个过程都会Stop The World，用户线程都会被挂起，应用程序的延迟变高。所以像CMS，G1等后来出现的收集器，都采取了回收过程可以与用户并发执行的做法，减少STW的时间，降低延迟，CMS，G1实现与用户线程并发的阶段称为“并发标记”阶段，而可以支持并发标记标识出存活对象的方法就是我们本篇的主题：**三色标记法**。CMS，G1收集器都使用了三色标记法，go语言的垃圾回收也使用了该算法，这也是高级java开发一道常见面试题。   

## 三色标记法    
三色标记法顾名思义就是给对象3种颜色，白色、灰色和黑色，经过最终标记后，对象要么是存活的黑色，要不是不再存活的白色。      
白色：初始时所有对象都是白色的，表示没被垃圾收集器访问过，如果标记结束都，对象仍然是白色的，那么表示不再存活，可以被回收。   
灰色：表示被垃圾对象访问过，但它至少还有一个引用没被访问，灰色是一个中间状态。   
黑色：表示对象直接或间接被gc roots引用着，且它的所有引用关系都访问过了，是存活对象。    

三色标记法的作用是从gc roots出发，按照三种颜色从白色->灰色->黑色不断推进标记堆中对象的过程，最终找到黑色存活的对象，回收白色不再存活的对象。    
下面我们通过图示来分析三色标记法整个过程，以及它可能出现的问题，如下图：  
![image](1)

初始阶段只有gc roots是黑色的，然后从gc roots开始遍历引用关系。   
阶段1将gc roots直接引用的对象A、E标记为灰色，因为它还有引用没遍历。   
阶段2找到A、E的所有引用，B、C、F，标记为灰色，并且A、E标记为黑色。    
阶段3找到B的所有引用D，由于C、F已经没有引用对象了，所以标记为黑色。   
同理阶段4会将D标记为黑色。   
而没被gc roots引用到的G、H就还是白色，最终会被回收。    

这个颜色标记，可以标记在对象头也可以使用单独的集合来存储，跟具体的垃圾收集器实现有关。我们可以简单理解每种颜色都有一个集合，标记过程就是把根可达对象从白色对象集合移到黑色对象集合，标记结束后黑色对象集合就是存活对象，白色对象集合就是垃圾。    

**三色标记法存在的问题**    
由于标记过程是与用户线程并发执行的，所以可能导致多标、漏标问题。    
如下图：  
![image](2)   

当C对象被标记为黑色表示存活对象，但由于用户线程的并发执行，A->C之间的引用关系可能断开了，也就是说C变成根不可达了，但它变成黑色，没有被回收。这种情况实际还好，最多就是本次没有被回收，下次gc还是会被回收。但下面这种情况就不一样了，如图：  
![image](3)    

当访问到灰色对象B，准备访问它的引用D时，此时：
1. 删除了B->D的引用关系      
2. 添加了A->D的引用关系   

删除了B->D的引用关系，B没有其它引用对象了，B就变成了黑色。但问题是删除了B->D的引用关系，D就访问不到，虽然添加了A->D的引用关系，但主要到A已经是黑色，不会再遍历一遍了。此时D被A引用着，但它却是白色的，会被回收，这会导致程序出错，是不可接受的。    

有两种方法解决这个问题：**增量更新**和**原始快照**(Snapshot At The Begining，也称为**STAB**)，CMS采用增量更新，G1采用原始快照。    
要出现上面的问题，需要满足两个条件：   
1. 赋值器插入了一条从黑色对象到白色对象的引用关系    
2. 赋值器删除了灰色对象到白色对象的引用关系    

解决这个问题只需要破坏其中一个条件即可。   

增量更新是破话第一个条件，在赋值器在为黑色对象新建引用关系的时候，把它记录下来，等到分析结束，把这些黑色对象作为根再分析一遍，这样就可以分析到新插入的引用关系了。也就是黑色对象插入白色引用后记录下来，重新放到灰色集合，再次分析，简单的说就是如果黑色对象新加引用关系，就变成灰色。    
那么再次分析会不会又有新的引用关系创建，这样就陷入死循环，分析不完了？不会，再次分析会STW，不会并发了，就是CMS中的重新标记阶段。    

原始快照是破坏第二个条件，赋值器虽然删除了灰色对象到白色对象的引用关系，但基于原始快照信息，我还是把白色对象变成灰色，灰色对象会再被分析，最终会变成黑色。同理G1的重新标记阶段也是会STW的。   

两种的不同点在于：    
增量更新把黑色对象重新变灰色后，需要重新分析这个对象的所有引用关系，如果这个对象的引用关系比较多，那么效率就会有所影响。   
而原始快照直接把白色对象变灰，最终变黑，就不需要重新分析一遍，相比之下效率更高，但如果此时赋值器做了第二步，但没做第一步，也就是没插入一条黑色对象到白色对象的引用关系，那么实际这个白色对象就是要被回收才对，但原始快照还是把它变成灰色，再变成黑色，没有被回收掉，这部分就称为“浮动垃圾”，本次gc就回收不了。    

从g1的设计角度出发，它的目标就是在可控的时间范围内，尽可能多的回收内存，所以产生有一些浮动垃圾没关系，下次回收就好了。    
顺便提一下，增量更新和原始快照都需要感知到赋值操作，这一点是通过jvm**写屏障**实现的，写屏障可以理解为jvm在引用对象赋值时，前后添加的一些逻辑，这和spring AOP思想上是一样的。尽管写屏障在赋值时做了一些操作会影响赋值性能，但相比为了后续gc所提升的作用，是可以忽略不计的。   

此外，对于更加先进的垃圾收集器ZGC来说，采用的染色指针，染色指针的意思就是在指针上存储一小部分关键信息，这样就可以直接通过指针获得对象信息，效率更高，在ZGC中三色标记就是记录在对象指针标记位上。但ZGC直到jdk19还没有转正称为jvm默认的垃圾收集器，先了解一下即可，不过未来肯定会替换G1。   






