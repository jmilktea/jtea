多线程编程是每一个开发必知必会的技能，在实际项目中，为了避免频繁创建和销毁线程，我们通常使用池化的思想，用线程池进行多线程开发。    
线程池在开发中使用频率非常高，也包含不少知识点，是一个高频面试题，本篇总结线程池的使用经验和需要注意的问题，更好的应对日常开发和面试。     
个人能力有限，欢迎补充~

- 异常处理     
如下代码，你猜下在控制台会打印什么？
```
	public void test() throws InterruptedException {
		ExecutorService executorService = Executors.newFixedThreadPool(1);
		executorService.execute(() -> {
			//业务处理
			throw new RuntimeException("execute error");
		});
		executorService.submit(() -> {
			//业务处理
			throw new RuntimeException("submit error");
		});
		Thread.sleep(10000);		
	}
```
答案是会打印“execute error”的异常堆栈，“submit error”的则不会打印，这里我们需要先了解java异常处理机制。    
线程是cpu的最小执行单元，java中的Thread就是对应一个内核线程，java代码首先要经过编译器编译为字节码，再交由jvm执行。当在执行过程jvm发现程序异常时，就会将异常抛出，由线程异常处理器处理。具体是调用线程的dispatchUncaughtException，并把异常作为参数传递。这是个私有方法，由jvm负责调用，如下：   
![image](1)     

**UncaughtExceptionHandler**就是定义在Thread的内部类，表示异常处理器，我们可以在创建线程的时候给它赋值，例如：   
```
	public void test() throws InterruptedException {
		Thread thread = new Thread(() -> {
			throw new RuntimeException("error");
		});
		thread.setUncaughtExceptionHandler((t, e) -> {
			e.printStackTrace(System.err);
		});

		thread.start();

		Thread.sleep(3000);
	}
```
那么平时我们没有定义异常处理器，它又是怎么处理的呢？如下可以看到当没有设置时，使用的是ThreadGroup对象，ThreadGroup也实现了UncaughtExceptionHandler接口，它的uncaughtException方法如下。   
![image](2)   

![image](3)    

可以看到它会判断是否有父ThreadGroup，如果有就往上抛，最终肯定会抛到一个顶层的ThreadGroup(name为system)，也就是执行图中的else部分。   
首先会通过Thread.getDefaultUncaughtExceptionHandler()获取全局默认的异常处理器，这个处理器可以通过Thread.setDefaultUncaughtExceptionHandler静态方法进行设置，如果有则使用全局默认处理器进行处理，否则将线程名称和异常堆栈打印到标准错误输出System.err，也就是控制台。   





1.
2.线程池traceid打印问题
3.线程池ThreadLocal问题
4.核心参数，有意义的线程名称，每种业务一个线程池，与tomcat/hystirx线程池的区别
5.父子线程公用一个线程池问题
6.线程池统计数据问题
7.动态线程池，监控
8.CompltetFuture/async stream 默认线程池问题
9.shutdown问题
10.内存泄漏问题
11.协程