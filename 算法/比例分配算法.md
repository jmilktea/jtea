**背景**   
实际项目中有这么一个需求，需要按照供应商设置的比例为其分配任务，一个任务只能分配给一个供应商，尽量保证公平。例如有两家供应商A,B，设置了比例是4:6，假设有1w个任务，那么希望A分到4000个，B拿到6000个。另外这些任务是源源不断产生的，也就是不是一次性就分完的，比如分完前面1w个后，又产生了10个，这个时候A应该分到4004，B是6006。当然，供应商不只两家，可能是n家。       

**分析**     
先假定只有一个任务，那么应该分配给谁呢？按照比例，理论上应该分配给比例比较大的这家，毕竟它比较需要数据。   
那如果有两个任务，第二个应该分配给谁呢？为了尽量保证公平，不能继续把它分配比例大的一家，而是分配给比例第二大的那家，否则会出现前面的数据都只分配比例大的，例如A:B = 99:1，如果只有99个不能都只分配给A。   
有了这个基础，我们就知道分配是按照**ABA**模式进行的。   

如下，每个框代表一个任务，假设有10个任务，A:B比例是4:6，那么结果如下    
![image](https://github.com/jmilktea/jmilktea/blob/master/%E7%AE%97%E6%B3%95/images/ratio-1.png)    

如果有3家供应商，A:B:C比例是2:3:5，那么结果如下   
![image](https://github.com/jmilktea/jmilktea/blob/master/%E7%AE%97%E6%B3%95/images/ratio-2.png)    

举一个复杂一点的例子，A:B:C比例是3:11:17，那么结果如下    
![image](https://github.com/jmilktea/jmilktea/blob/master/%E7%AE%97%E6%B3%95/images/ratio-3.png)    


## 实现
**方式一**   
最简单的方式就是把已分配的数量记下来，每次判断是否达到比例，如果没有分配给已有数量最小的那个，如果数量相同，就分配给比例最大的那个。   
这种方式需要逐个比例判断比较麻烦，例如先判断A:B，在判断B:C。另外可能存在并发问题，例如同时有多个线程在进行计算。    

**方式二**      
通过上面的图可以看到，当分配到一定数量后，就有的不需要再分配了，图中加粗部分，这个位置我们姑且称之为“临界位置”，超过临界位置后可分配节点就会-1，这个动作我们称为“节点退出”。   
假设供应商个数是n，我们先按照比例大小从小到大排序，分别是I1,I2,...In，比例总和 I1 + I2 + ... + In 记为 Sn         
剩余可分配节点记为C，初始时 C = n  
临界位置使用P表示，分别是P1,P2,...Pn      
那么第m个点的临界位置的计算公式为：Pm = P1 + P2 + ... + Pm-1 + (Im - Im-1) * 1    
当有节点达到临界位置，就会发生节点退出，此时：C = C - 1   
任务当前个数是T，例如当前是第10个任务，T就等于10，下一个任务T就为11，Pm表示最近一个临界位置       
那么第T个任务应该分配给供应商的下标计算公式为：**r = (T - Pm) % Sn % C**    

在初始时我们都先计算P，保存下来，当分配T任务时，只需要先计算C即可。    
以上面A:B:C 为 3:11:17的例子，下标分表是0,1,2。初始 Sn = 31，C = 3   
```  
P1 = 3 * 3 = 9   
P2 = P1 + (11 - 3) * 2 = 25   
P3 = P1 + P2 + (17 - 11) * 1 = 31  
```   
那么第3个任务，还没达到最小临界位置，此时C = 3，r = （3 - 0） % 31 % 3 = 0，分配给下标为0的A    
那么第10个任务，已经超过P1，但是没超过P2，此时C = 2，r = （10 - 9） % 31 % 2 = 1，由于A已经退出，下标变成B=0，C=1，此时分配给C   
那么第19个任务，已经超过P1，但是没超过P2，此时C = 2，r = (19 - 9) % 31 % 2 = 0，由于A已经退出，B = 0，此时分配给B   
那么第26个任务，已经超过P2，但是没超过P3，此时C = 1，r = (26 - 25) % 31 % 1 = 0，此时A,B都已经退出，C = 0，所以分配给C      

其它比例也可以按照上述的方式推算出来，得到想要的结果了。   
T的实现，T是个计数，每产生一个任务我们就+1即可，这个可以使用redis的incr命令轻松实现。       









