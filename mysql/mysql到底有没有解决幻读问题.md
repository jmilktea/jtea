mysql有没有解决幻读问题，在网上的答案比较多，有的斩钉截铁的说有，有的说解决部分情况下，如果有解决是使用什么方式解决的，这也是一个比较常见的面试题，我们来分析一下。     

首先什么是幻读，就是在事务内的两次读，读到不同的行集。举个栗子：   
```
start transaction;
-- 假设现在有id：1,5,10,15
-- 第一次读返回1,5,10
select * from t_table where id between 1 and 10;

-- 第二次读返回1,5,6,10
select * from t_table where id between 1 and 10;
```
假设上述的情况在第一次读后，另一个事务往表里插入一条id=6的记录，若第二次读比第一次读返回的结果了一条6的记录，这条记录就称为幻行，这种情况就称为幻读。     
有的同学可能会混淆不可重复读和幻读，因为本质上两者都是多次读取到不一样的结果，但是幻读侧重于行集，读到的数据多了或少了，这一点我们这[MVCC原理]()这一篇也有提及，MVCC原理这一篇也推荐阅读，读完后会更好理解本篇的内容。    
另外我们也可以看mysql官网对幻读的描述：[Phantom Rows](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)    

**前提**    
1. 在讨论幻读，首先要说明当前使用的事务隔离级别是什么，网上很多文章脱离事务隔离级别在讨论的，都是耍流氓。     
我们这里讨论的事务隔离级别是：可重复读(RR)，这也是mysql默认的事务隔离级别，其它事务隔离级别在讨论幻读是没有意义的。    

2. 多版本并发控制(MVCC)，这一点我们在[MVCC原理]()介绍了，mysql通过MVCC实现并发访问，提升效率，MVCC里面有两个重要概念，版本链和一致性视图    

3. next-key lock，RR下加锁的基本单位，是一个前开后闭的区间，是行锁和间隙锁的组合，可提交读(RC)下是没有的     

4. mysql版本，这里我们基于5.7.34，对于不同版本next-key lock可能有不同表现，例如mysql在高版本修复了一些bug    

**例子**    


