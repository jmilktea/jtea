在开始MVCC原理前，让我们先回顾一下数据库中事务相关的三大问题、四个特性和四种隔离级别。     

## 三个问题   
- 脏读    
在事务一中读取到事务二未提交的数据，这个数据很可能是错的，事务二后面会把它回滚掉，此时如果事务一读到这个数据并且拿来使用，就有可能出现错误。在事务内读取到其它事务未提交的数据情况就称为脏读。  
- 不可重复读   
在事务一开始读到数据A，事务二将数据修改为B并提交，事务一再次读取发现数据变成B，事务内两次读取结果不同。这种在事务内读取到其它事务提交的数据则称为不可重复读。  
- 幻读   
在事务一开始读取符合条件的记录A,B,C，事务二新增了一条服和条件的数据D并提交，事务一使用相同条件再次读取时，发现结果变成A,B,C,D，比原先多了一条记录。幻读看起来和不可重复读非常相似，主要是两者都表现为读取到的结果不一致，两者主要差别是：不可重复读只针对某行数据，而幻读针对的是一个范围，解决不可重复读只要锁定当前这条数据（修改），而幻读需要锁定符合条件的范围（新增）。    

## ACID   
- 原子性    
一个事务内的多个操作要么同时成功，要么同时失败，不会出现部分成功的情况。   
- 一致性   
一致性的书面定义是：事务的执行结果总是从一个一致性状态到另一个一致性状态。可以理解为一致性是数据库一种正确的结果（包括结果正常，满足约束），那么随着事务的执行，数据库也始终保持这种正确的结果。   
- 隔离性    
当多个事务并发执行时，通过隔离性还解决不同事务间的相互影响。   
- 持久性  
当事务提交后，数据就持久化了，就算发生宕机，下次重启也能恢复到上次的一致性结果。   

## 隔离级别   
- 读未提交   
事务一读到事务二未提交的数据，在这种隔离级别下，会发生脏读。  
- 读提交（read committed RC）  
事务一读到事务二提交的数据，在这种隔离级别下，不会发生脏读，但是会出现不可重复读和幻读。   
- 可重复读（repeatable read RR）   
事务一内读到的数据总是和第一次读取到的是一样的，在这种隔离级别下，不会发生脏读和不可重复读，但还是可能出现幻读。   
- 串行化   
串行二字已经表明了它是严格按照事务顺序执行，不存在并发问题，在这种隔离级别下，上面三个问题都不会发生。   

这几种事务隔离级别随着不断严格要求，能解决的问题越来越多，但性能也随着下降，一般情况下读未提交和串行化这两种我们都不会使用。重点关注读提交（RC）和可重复读（RR）这两种，RR是mysql默认的隔离级别，如果我们使用阿里云的mysql，为了提高性能，它的隔离级别是RC。   

## MVCC原理    
MVCC(Multi-Version Concurrency Control)多版本并发控制，是mysql控制并发访问的一种手段。  
MVCC是在数据库引擎级别实现的，用来处理并发读写的手段，提升访问性能，MVCC只有在隔离级别为RC和RR时才有效。   
MVCC里有两个重要的概念，**版本链**和**一致性视图**。   

### 版本链    
定义：版本链是数据修改历史所串联起来的一种结构，它通过一个指针将各个版本串联起来，形成一种类似链表一样的数据结构。  
在mysql中，每行数据还包含如下隐藏字段：  
- trx_id：保存了修改这条数据的事务id，这个id是全局递增的    
- roll_ptr：一个指向上一次修改记录的指针   
- row_id：行id，如果我们自己设定了主键，就会使用它，否则mysql会为每行数据生成一个row_id    

![image]()   

roll_ptr指针到底指向什么？？？这个问题我们必须先搞清楚，上面说到它指向上一次修改记录，我们表里数据只有一份，难道mysql把每次修改都做了记录？记录到哪里？   
没错，mysql确实把每次修改都做了记录，这种记录每次变动的日志就是：**undo log**   
#### undo log   
undo log从名字上可以看到，它是do的反向，提供回滚功能。undo log的主要作用就是为事务回滚和mvcc服务，roll_ptr指针就是指向undo log的位置。      
mysql每次修改前（insert/update/delete）都会写undo log日志，随着时间线的推前，多次修改后，就形成数据修改历史的链式结构，如图：

![image]()   

数据的最开始由事务100的insert产生，insert也会写undo log，只不过它不需要记录旧值。    
接着事务200开始执行update语句，此时会修改trx_id会200，并写入一条undo log，undo log会包含旧值，当事务需要回滚时就是用这个旧值来实现恢复。并且roll_ptr指针会指向这条undo log。  
接着事务300开始执行update语句，此时与事务200的步骤一样，写undo log，trx_id,roll_prt设置为当前值。   
接着事务400开始执行update语句，此时与事务200的步骤也是一样的，我们可以看到随着时间的推移，经过roll_ptr的串联形成了一个链表式的版本链。   

细心的同学可能马上会提出疑问，这样undo log岂不是越来越大，版本链也越来越长？   
实际上undo log是会清理的，对于insert语句，事务提交后就会立即清理，对于update(delete也是update的一种)，事务提交后不会马上进行清理，而是由mysql的Purge线程在合适的时候进行清理，这样保证undo log不会膨胀。那么为什么update后不能立即清理undo log呢？不能立即清理的原因是别的事务可能还在用，这个就跟一致性视图有关了。

### 一致性视图    
定义：一致性视图解决的是，数据对于事务的可见性问题。  
上面提到的版本链，那么在一个事务里，我们看到的是哪个版本的数据呢，也就是哪个版本对于当前事务是可见的，这就是一致性视图要定义的事情。   
对于读提交（RC）和可重复读（RR）隔离级别，它俩之间的区别是生成一致性视图的时机不同，RC是每次读都会新生成一致性视图，而RR只会在第一次生成，后面都使用该视图（这里我们可以知道为什么叫可重复读了吧，因为视图在第一次生成就固定了，后面都是读的都是同一个）  
一致性视图有几个重要的属性，如下：  
- m_ids：当前活跃的事务id集合   
- min_trx_id：m_ids中最小值   
- max_trx_id：m_ids中最大值+1  
- creator_trx_id：生成该事务的id      

通过上面几个属性就可以判断哪个版本对当前事务是可见的，判断的规则如下：   
- 当 trx_id = creator_trx_id 表示数据是当前事务修改的，可见
- 当 trx_id < min_trx_id 时  修改数据的事务已经在生成当前ReadView前提交了，可见
- 当 trx_id >= max_trx_id 时 修改数据的事务是在生成ReadView后才开启的，不可见
- 当  min_trx_id <= trx_id < max_trx_id 时
    - trx_id 在 m_ids 列表里面，表示生成ReadView时，活跃事务还未提交，不可见
    - trx_id 不在 m_ids 列表里面，表示事务在生成ReadView前已经提交了，可见

在分析这些规则前我们先明白两个问题   
- 什么时候会生成事务id？start transaction就开始生成事务id吗？   
需要注意的是，事务id是在事务内执行第一个操作语句（insert/update/delete）生成的一个全局递增的id，单纯的声明start transaction不会生成事务id。   
- 当前读与快照读   
当前读每次都是读取数据的最新版本，怎么保证每次都是最新版本呢？答案就是加锁，mysql中select... for update,select... lock in share mode都是加锁来实现当前读。  
快照读是允许读到数据的旧版本，普通的select语句就是快照读，快照在并发读写的场景下不需要加锁，性能较高。我们上面提到的读也是快照读。   

对于上面提到的可见规则，单纯从文字理解起来比较费劲，我们通过例子来分析一下，起始数据还是上图中id=1,name=tom这条记录，重点分析图中红字读的部分，上面我们也说到RC,RR生成一致性视图的时机不同，这里分开说明。  
![image]()   

#### 读提交（RC）
**RC级别下，每次读都会生成一致性视图**   
T1时刻，事务200,300,400,500都开启事务    
T2时刻，事务200修改name为A
T3时刻，事务300等待锁
T4时刻，事务400,500并发读这行数据，此时版本链如下  
![image]()   

生成一致性视图为：  
- mids:[200,300]
- min_trx_id:200
- max_trx_id:301
- creator_trx_id：0，因为还没真正执行修改语句，并没有生成事务id    

当前数据的trx_id是200(300还没获取到锁)，符合min_trx_id <= trx_id < max_trx_id，并且trx_id在mids[200,300]内，表示200还是活跃的事务，还没提交，所以不可见。  
接着使用roll_ptr指针，开始寻找上一个版本，发现上一个版本的事务id是100，符合trx_id < min_trx_id，表示这个版本已经在生成ReadView前提交了，可见，此时读取到的值是："tom"   

T5时刻，事务200正常提交事务，事务300获取到锁，修改name为B       
T6时刻，事务400等待锁  
T7时刻，事务500读取数据，此时版本链如下  
![image]()   

生成一致性视图为：  
- mids:[300,400]
- min_trx_id:300
- max_trx_id:401
- creator_trx_id：0，因为还没真正执行修改语句，并没有生成事务id  

当前数据的trx_id是300，符合min_trx_id <= trx_id < max_trx_id，并且trx_id在mids[300,400]内，表示300还是活跃的事务，还没提交，所以不可见。  
接着使用roll_ptr指针，开始寻找上一个版本，发现上一个版本的事务id是200，符合trx_id < min_trx_id，表示这个版本已经在生成ReadView前提交了，可见，此时读取到的值是："A"   

T8时刻，事务300正常提交事务，事务400获取到锁，修改name为C     
T9时刻，事务400读取数据，此时版本链如下  
![image]()  

生成一致性视图为：  
- mids:[400]
- min_trx_id:400
- max_trx_id:401
- creator_trx_id：400   

当前数据的trx_id是400，符合trx_id = creator_trx_id，表示数据是当前事务修改的，可见，此时读取到的值是："C"   


#### 可重复读（RR）
**RR级别下，只第一次生成一致性视图**    
还是上面的例子，RR级别下，一致性视图只生成一次，上面的主要不同点在于事务500的两次读，RC下第一次读取到"tom"，第二次读取到"A"，这是因为两次生成的一致性视图不同，出现不可重复读。  
RR级别下，生成的一致性视图为：  
- mids:[200,300]
- min_trx_id:200
- max_trx_id:301
- creator_trx_id：0，因为还没真正执行修改语句，并没有生成事务id    

所以每次读取到的都是“tom”。   

回到前面提到的问题，为什么update的undo log不能立即删除？因为在RR级别下，只要事务还没提交都需要同一个一致性视图，那么另一个事务提交的可能是一致性视图中的一部分，还被引用着，所以不能删除。而insert的undo log只为回滚，没被MVCC使用到，所以可以直接删除。   

一些参数  
```
show variables like '%undo%';
show variables like '%purge%';

innodb_max_undo_log_size：undo log文件大小阈值，达到这个值就会触发回收   
innodb_undo_directory：undo log文件目录   
innodb_purge_threads：undo log清理线程数，默认是4   
```

