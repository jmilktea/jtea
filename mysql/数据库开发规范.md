数据库往往是系统最先出现瓶颈的地方，良好的规范可以避免很多不必要的问题，提升系统的性能和可维护性。     
本文主要从数据库和程序的角度出发，总结相关开发规范，欢迎补充。         

# 命名规范
对象 | 格式      
---|---
表 | t_名称 
视图 | v_名称 
索引 | idx_字段名称 
   || 唯一索引 uidx_字段名称
存储过程 | pro_名称
事件 | e_名称

- 使用富有意义的英文词汇    
说明：所有对象命名(表/字段/索引等)一律小写，尽量不要缩写，多个单词用_分隔。           

- 对象名长度不能超过32个字符     
说明：实在太长就考虑缩写吧。    

- 避免使用mysql的关键字     
说明：如type,name,status，加``也不行，使用pt工具可能会报错，如sharding-jdbc一些开源组件遇到关键字可能也会报错。      

- 索引用index关键字     
说明：key和index一样，就统一用index吧。        


# 建表规范
- 使用innodb存储引擎      
说明：没啥好说的。    

- 表名、列名必须有备注    
说明：可以方便后续人员快速上手，方便字典建设。    
如果你做的是国际化的项目，建议备注都使用英文，方便后续合规审计。    

- unsigned类型    
说明：这是个有趣问题，unsigned可以使正数范围扩大两倍，但java的数字类型却没有无符号类型。unsigned的另一个作用是在数据库级别上限制异常数据的插入，例如年龄不可能是负数，通常我们再程序上也做了验证，数据库上的限制是最终保险，遵守墨菲定律，[参考](https://www.zhihu.com/question/275813458)。     

- 字段的含义改变，需同时修改备注     
说明：常见如枚举值变化。     

- 主键：id bigint unsigned    
名称为：id，统一命名有利于在程序做继承，拦截等。   
类型为：bigint unsigned，不要使用int，int的范围太小。笔者在工作过程已经多次遇到表数据量超过int造成的事故。   
不允许使用自增：自增类型无法支持分库分表，在程序用雪花id算法生成。有些dba会建议是使用自增id，以获得更加紧凑和高效的主键。    

- 选择合适数据类型       
说明：能用int就不要用bigint，能用数字就不要用字符串。    
与外部系统交互的，尽量使用字符串类型。     

- 表达状态最好用tinyint      
说明：不要使用bit类型，最好也不要取名is_xxx，后续不好扩展。     

- 金额类型统一用decimal  
说明：精度问题，不要使用float和double。  

- not null default      
说明：null对索引支持不好，占用多1个字节空间，程序需要判断空值。         

- 不允许存储图片，文件等二进制数据      
说明：使用文件，图片服务器。    

- 字符集用utf8mb4，不要用utf8  
说明：mysql utf8是假的，永远不要用它。一般在数据库和表级别设置，单个字段不需要设置。       

- 字符长度确定应使用char，否则使用varchar     
说明：char的效率较高。varchar可以动态存储空间，使用varchar应指定合适的长度。    

- 不允许使用外键  
说明：外键对性能影响很大，要在程序端控制。  

- 合理进行冗余设计，避免关联查询    
说明：但不能是频繁修改的字段，不能是占用空间大的字段。   

- 垂直拆分  
说明：一开始就应该考虑垂直拆分表，不要一股脑都放在一个表里，后面表数据量大时加字段非常麻烦。    

- create_time和update_time字段     
说明：每张表都需要这两个字段，且不表达业务含义，都需要建索引，方便数仓获取数据和跟踪数据。     
无论是程序修改数据，还是人工修复数据，update_time字段都必须更新。       

- 关联字段设计需要和来源表保持一致     
说明：t_user表user_name字段为varchar(255)，那么其它表有该字段的应该类型和长度都要保持一致。主表在设计时需要仔细，尽量不要修改。      

- 设计表要从业务角度出发    
说明：举个例子，有一个界面展示信息列表，点击会弹出详情，这两者可能是同一个业务同一个维度的东西，不需要拆成两张表，但由于开发习惯性思维，把它拆分两张表设计。
需要知道的是，ui是多端多变的，我们不能因为ui的改变就影响表的设计或者接口的设计。   

# 索引规范
- 建立合适的索引  
说明：常查询，少更新，区分度高的字段适合建索引。   

- 索引数量不宜过多    
说明：占用空间，影响插入/修改/删除，增加查询时的索引评估成本。   

- 避免重复建立索引     
说明：建立(a,b,c)复合索引，就相当于建立了(a,b,c),(a,b),(a)三个索引。    

- 业务上有唯一性的，建立唯一索引  
说明：避免脏数据，查询效率高。     

- 使用前缀索引      
说明：超过20个长度的字符串列，建议创建前缀索引而非整列索引，减少存储空间。例如：idx_name(name(20))。     
innodb对索引长度有限制，一些太长的字段只能建前缀索引。        

- 多表关联，关联字段必须建立索引           

- 索引字段不要使用函数计算     
说明：索引会失效，8.0版本支持函数索引。    

- sql参数必须和字段类型保持一致      
说明：类型转换，索引失效，全表扫描。    

- 禁止使用左模糊/全模糊查询  
说明：索引最左前缀匹配特效，最左无法确定，无法利用索引。  

- 利用复合索引，避免回表二次查询   
说明：区分度高的放前面。    

- order by 索引有序性  
说明：排序尽量建立在有索引的列上。排序列与索引列次序保持一致。    

# 数据库
- 不允许使用存储过程，触发器       

- 数据库开启慢查询监控，及时优化      

- 使用Read Commit事务隔离级别  
说明：并发性较好，mysql默认是RR，云厂商的一般是rc。    

- 更新脚本时，相同表的操作写在一起  
说明：一次变更  
如：
```
ALTER TABLE account ADD INDEX idx_create_time(create_time);
ALTER TABLE account ADD INDEX idx_update_time(update_time);
```
应写成：
```
ALTER TABLE account ADD INDEX idx_create_time(create_time),
ADD INDEX idx_update_time(update_time);
```

- drop/truncate
说明：不允许此类语句操作，实在要操作多人审批，且先备份再进行。        

- 时间存储为0时区  
说明：数据时间都为0时区，转换其它时区在应用层处理。    

- 尽量使用简单通用的sql写法     
说明：复杂的sql难以理解和维护，或者不具备通用性，使用一些特殊的数据库方法或语法需要考虑程序框架或数据库代理中间件是否支持。    
例如sharding-jdbc 4.x版本不支持mysql in((a1,b1),(a2,b2),(a3,b3)) 多个字段的写法。    

- 尽量使用mysql8.0版本  

- 定期历史数据进行归档，缩容   

# SQL 规范    
- 尽量不要使用子查询，用join改写     
说明：mysql会将子查询改写为semijoin已获得更优的执行计划，但不是每次都能成功，如：[这样delete居然不走索引](https://github.com/jmilktea/jtea/blob/master/mysql/%E8%BF%99%E6%A0%B7delete%E5%B1%85%E7%84%B6%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95.md)。    

- in()数量不宜过多    
说明：应该分批操作，例如1000个，有些数据库代理可以做这个限制。      

- in里不要使用子查询  
说明：应该拆分，先把子查询结果查出来，作为参数再去in查询。   

- sql变量必须参数化     
说明：sql注入。          

- 利用延迟关联或者子查询优化超多分页场景  
说明：mysql查询是取offset+N行，放弃前offset行，返回N行。当offset 较大时，效率就非常的低下，要么控制返回的总页数，要么通过二次查询，先查询id再关联查询解决。

- 不需要排序时使用union all 代替 union     

- 禁止使用insert into table values()     
说明：必须显示指定列明，防止新增字段报错。

- 禁止使用负向查询  
说明：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE。      

- 不要在sql层面做运算，逻辑处理       

- 批量操作不宜过大        
说明：批量处理在一个链接内完成，节省链接的获取时间。批量处理注意数量不宜过大，避免sql拼接过长，占用大量内存，一般建议不超过100个。  
我们经常会定时清除一些日志表，如1年以前的数据。注意不要一个delete清除，否则可能会因为要清除的数据太大，影响性能，也是要小批量进行。         

- 避免多表使用join    
说明：尽量不要多张表使用join关联查询，特别是大表，拆成多个小的查询。    

- 只能通过主键操作数据    
说明：update/delete的where条件都应该是主键(避免是普通索引)，不是索引更不行，相当于给每行数据加锁。     

- 分页不要count总数    
说明：innodb的count非常慢，可以从业务上折中，count总数一般意义不大。       

- 不要使用物理删除     
说明：实在要物理删除时，也要先备份一下数据。    

- 避免使用select...for update  
说明：select...for update是先加锁，会降低并发效率。     

- 避免使用insert... on dumplicate update    
说明：并发场景下容易产生死锁。      
笔者的团队有个项目有一个插入语句使用了它，突然有一天数据库链接打满，业务大量报错。     
经排查有张表主键使用了int类型，当时数据量已经超过int最大范围，超过int后mysql主键就不再自增，一直使用int MAX_VALUE进行on dumplicate update且程序也不会报错。但要命的是update会加行锁，并发高时连接数很快就会被打满，再获取时就会排队，超时失败。     
这个例子虽然直接不是on dumplicate update的锅，但也反馈了它一个弊端，当时排查过程花了不少时间，如果使用普通的insert/update就可以快速发现错误。      

- 注意下游影响      
说明：主要是数仓，数据库变更需要提前通知下游，因为下游也可能要修改，需要时间。      
如果对大量数据进行处理，需要提前通知下游，例如对大表某个字段全表进行更新，当天要同步的数据就可能过多，造成影响，需要提前问下游是否可以支撑，否则考虑每天分批修改。        

# 程序规范
- 不要使用 select  *    
说明：阿里java规范中强制要求：在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。   
1）增加查询分析器解析成本。 2）增减字段容易与 resultMap 配置不一致。 3）无用字段增加网络消耗，尤其是 text 类型的字段。    
我补充一点：在使用sharding-jdbc的时候，它会加载表字段元数据，然后与查询字段进行匹配，如果使用select *，在应用重启前添加数据库字段，会导致程序报错。     
代码位置：com.mysql.cj.protocol.a.MergingColumnDefinitionFactory#createFromFields      

- 注意主从延迟问题    
说明：主从架构可以分担主库压力，提升数据库读取效率。但主从同步有一定延迟，如果程序不注意容易出现问题。     
如果使用polardb，默认就是读写分离，它会自动根据sql的类型路由到写库，或者负载均衡到读库，对于程序是无感的。      
如果程序在写后需要立马读的，不要想当然可以读取到，要考虑延迟问题，很可能会读取不到，导致程序异常。      
对于porlardb，可以通过在sql前面新增/*FORCE MASTER*/注释强制走主库。   

- 合理设置连接池参数    
说明：连接数量不是越大越好，应该根据应用和数据库配置合理设置。   

- 对多个表的操作要保持顺序一致    
说明：例如程序有两个地方都会操作A,B表，那操作顺序应该都是A->B,不能一个A->B，一个B->A，避免产生死锁。    

- 最小事务粒度      
说明：事务内不要做其它IO操作，如调用外部接口，调用redis等，否则事务时间会比较长，锁的时间也会变长。     
以下两段代码，只是在书写上换了个顺序，性能上有什么差别吗？     
```
@Transactional(rollbackFor = Exception.class)
public void updateStock1(Long stockId, Integer num, List<StockLog> logs) {
   stockMapper.updateNum(stockId, num);
   logs.forEach(log -> logMapper.insert(log));
}
 
@Transactional(rollbackFor = Exception.class)
public void updateStock1(Long stockId, Integer num, List<StockLog> logs) {
   logs.forEach(log -> logMapper.insert(log));
   stockMapper.updateNum(stockId, num);
}
```
可以说在并发高的场景下，性能差距还是比较明显的。第一个语句update库存就会对该行加写锁，而锁的释放需要等到logs都添加完事务提交才释放，此时其它update库存都将无法操作。换顺序后，操作库存后立即提交事务，此时加锁的时间更短，并发性更好。     

- 只修改需要修改的字段     
说明：不要传一个实体对象，然后所有字段都update，这样容易出错，而且会增加binlog开销。      
使用mybatis plus等这一类orm框架容易忽视这个问题。    

- 重要的操作需要记录创建人，修改人       
说明：每个表都有创建时间，修改时间，重要的操作还需要记录创建人和修改人，方便追查。    

- 尽量记录快照信息      
说明：我们根据配置表A修改B表某些信息，这个时候需要记录B表修改记录是根据配置表A进行的，同时最好把当时配置表A的关键信息记录下来，因为这些信息可能会修改，后期就无法对正了。    

- 敏感字段要加密      
说明：涉及到敏感字段的都需要加密，防止被拖库数据泄露。       
比较容易遗忘的是有些字段是存储的是json格式化后的数据，例如json对象里面有电话字段，这种情况开发容易遗漏。      
