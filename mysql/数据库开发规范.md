数据库往往是系统最脆弱，也是最先出现的瓶颈的地方。良好的规范可以避免很多不必要的问题，提升系统的性能和可维护性。本文主要从数据库和程序的角度出发，总结相关开发规范。

## 命名规范
- 命名要使用富有意义的英文词汇，避免使用缩写，多个单词用_分隔

- 数据库对象名总长度不能超过32个字符  
说明：不宜过长  

- 不要使用mysql的保留字和关键字  
说明：加``也不行，使用pt工具时会报错，如type,name,status    

- 库/表/字段/索引，所有对象命名一律小写  

- 建索引统一用index 
说明：key和index一样，就统一用index吧    

对象 | 格式 
---|---
表 | t_名称 
视图 | v_名称 
索引 | idx_字段名称 
   || 唯一索引 uidx_字段名称
存储过程 | pro_名称
事件 | e_名称

## 建表规范
- 使用innodb存储引擎  

- 表名、列名必须有注释  
说明：可以方便后续人员快速上手，方便字典建设

- 不存在负数含义的字段统一用unsigned  
说明：墨菲定律  

- 字段的含义改变，应同时修改字段备注  
说明：常见状态值等  

- 主键：id bigint unsigned  
    - 名称为：id  
    说明：统一命名有利于在程序做继承，拦截等
    - 类型为：bigint unsigned    
    说明：不要使用int，int的范围太小
    - 不允许使用自增  
    说明：自增类型无法支持分库分表，应在程序用雪花id算法生成。（这里dba的建议是使用自增id，以获得更加紧凑和高效的主键）

- 选择合适数据类型  
说明：能用int就不要用bigint，能用数字就不要用字符串  

- 表达是与否的字段，统一用 tinyint unsigned  
说明：不要使用bit类型  

- 金额类型统一用decimal  
说明：不要使用float和double  

- 字段not null default 值    
说明：null对索引支持不好，占用多1个字节空间，程序需要判断空值。

- 不在数据库中存储图片或文件等大数据  
说明：使用文件服务器等

- 字符集用utf8mb4，不要用utf8  
说明：mysql utf8是个bug，永远不要用它。一般在数据库和表级别设置，单个字段不需要设置。

- 字符长度确定使用char，使用varchar应选择合适的长度  
说明：char的效率较高。varchar可以减少空间存储，但是mysql获取数据时，还是会分配指定的空间，所以长度不能太长  

- 不允许使用外键  
说明：外键影响性能  

- 合理进行冗余设计，避免关联查询    
说明：但不能是频繁修改的字段，不能是占用空间大的字段

- 垂直拆分  
说明：一开始就应该考虑垂直拆分表，不要一股脑都放在一个表里，后面表数据量大时加字段就是个噩梦  

## 索引规范
- 建立合适的索引  
说明：常查询，少更新，区分度高的字段适合建索引，索引不仅影响insert/update/delete，错误的索引还会影响查询

- 避免建立冗余索引  
说明：建立(a,b,c)复合索引，就相当于建立了(a,b,c),(a,b),(a)三个索引

- 业务上有唯一性的，建立唯一索引  
说明：避免脏数据，查询效率高  

- 使用前缀索引  
说明：超过20个长度的字符串列，建议创建前缀索引而非整列索引，减少存储空间。例如：idx_name(name(20))

- 索引长度限制  
说明：innodb单个索引长度限制为767字节，联合索引限制为3072字节。varchar(255)之类的字段一般是设计不合理，或者不适合建索引    

- 多表关联，关联字段必须建立索引  
说明：详情见mysql join原理  

- 索引字段不要使用函数计算  
说明：索引会失效。8.0版本支持函数索引。    

- 利用复合索引，避免回表二次查询   
说明：区分度高的放前面

- order by 索引有序性  
说明：排序尽量建立在有索引的列上。排序列与索引列次序保持一致  

- 禁止使用左模糊/全模糊查询  
说明：索引最左前缀匹配特效，最左无法确定，无法利用索引  

- sql参数必须和字段类型保持一致  
说明：类型转换，索引失效，全表扫描    

- 单表索引建议不超过5个  

## SQL 规范
- 尽量不要使用子查询，用join改写  
说明：mysql子查询效率低  

- in个数不超过1000
说明：dba一般会设置这个限制  

- in里不要使用子查询  
说明：应该拆分，先把子查询结果查出来，作为参数再去in查询

- sql变量必须参数化，防止注入  

- 查询结果不允许使用map接收  
说明：老老实实定义实体接收吧  

- 利用延迟关联或者子查询优化超多分页场景  
说明：mysql查询是取offset+N行，放弃前offset行，返回N行。当offset 较大时，效率就非常的低下，要么控制返回的总页数，要么通过二次查询，先查询id再关联查询解决。

- 不需要排序时使用union all 代替 union  

- 禁止使用insert into table values()  
说明：必须显示指定列明，防止新增字段报错

- 禁止使用负向查询  
说明：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE

- 不要在sql层面做运算，逻辑处理  

- 批量insert  
说明：批量处理在一个链接内完成，节省链接的获取时间。批量处理注意数量不宜过大，避免sql拼接过长，占用大量内存，一般建议100个左右。  

- 小批量清理数据  
说明：我们经常会定时清除一些日志表，如3天以前的数据。注意不要一个delete清除，否则可能会因为要清除的数据太大，导致数据库告警。建议一次清理1000条，循环进行。  

- 避免使用join  
说明：尽量不要使用join关联查询，特别是大表。拆成多个小的查询，连接池不会导致频繁建立连接。  

- 只能通过主键操作数据  
说明：update/delete的where条件都应该是主键(避免是普通索引)，不是索引时相当于给每行数据加锁

- 分页不要count总数    
说明：innodb的count非常慢，可以从业务上折中，count总数一般意义不大  

- 不要使用物理删除  

- 避免使用select...for update  
说明：select...for update是先加锁，会降低并发效率

- 避免使用insert... on dumplicate update    
说明：并发场景下容易产生死锁。      
举例：笔者的团队有个项目有一个插入语句使用了它，突然有一天数据库链接打满，业务大量报错。     
经排查有张表主键使用了int类型，当时数据量已经超过int最大范围，超过int后mysql主键就不再自增（使用MAX_VALUE），一直使用相同id进行on dumplicate update且程序也不会报错，update会加行锁，并发高时连接数很快就会被打满，再获取时就会排队，超时失败。     
这个例子虽然直接不是on dumplicate update的锅，但也反馈了它一个弊端，当时排查过程花了不少时间，如果使用普通的insert/update就可以快速发现错误。      

## 数据库
- 不允许使用存储过程，触发器，视图    

- 数据库开启慢查询监控，及时优化  

- 使用Read Commit事务隔离级别  
说明：并发性较好，mysql默认是RR

- 更新脚本时，相同表的操作写在一起  
说明：一次变更  
如：
```
ALTER TABLE account ADD INDEX idx_create_time(create_time);
ALTER TABLE account ADD INDEX idx_update_time(update_time);
```
应写成：
```
ALTER TABLE account ADD INDEX idx_create_time(create_time),
ADD INDEX idx_update_time(update_time);
```

- 小心drop或者TRUNCATE   
说明：删库到跑路...，不应直接进行此类语句操作，应先rename对表进行备份  

- 时间存储0时区  
说明：数据时间都为0时区，在应用层做处理  

- 除非能预计三年内表数据过千万，否则一开始不需考虑分表

- 尽量使用sql92标准语法  

- 使用mysql8.0版本  

- 对历史数据进行归档，缩容  

## 程序规范
- 合理设置连接池参数  
说明：连接数量不是越大越好，应该根据系统参数设置

- 使用mybatis时，考虑禁用一级缓存  
说明：mybatis默认开启session级别的一级缓存，在单体项目下可以提高性能。但在Read-Commited事务隔离级别下，并且多节点部署服务，可能会读缓存而没读取到最新的值

- 对多个表的操作要保持顺序一致  
说明：例如程序有两个地方都会操作A,B表，那操作顺序应该都是A->B,不能一个A->B，一个B->A，避免产生死锁

- 保持小粒度事务粒度   
说明：事务内最好不要做其它操作，如调用外部接口等，否则事务时间会比较长，锁的时间也会变长

- 只修改需要修改的字段  
说明：不要传一个实体对象，然后所有字段都update，这样容易出错，而且会增加binlog开销  
