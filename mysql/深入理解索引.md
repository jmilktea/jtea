## 前言   
索引是类似于目录一样的东西，可以加快查找速度。想象一下，一本几十万字的字典，如果找一个字要一页一页找，无异于大海捞针，而字典的目录可以让我们通过拼音或者偏旁，快速定位到它在哪一页，很快就可以找到，这是我们对索引最直观的理解。在实际开发中很多开发人员也只是根据查询简单的建建索引，只知其一，不理解底层的原理，很难有所突破。另外索引也是高频的面试题，例如从浅到深可以有这样的连环炮：  
- 索引的优点是什么，缺点是什么   
- 哪些字段适合建索引，哪些不适合，为什么    
- 如何判断一个索引是好是坏  
- mysql innodb索引底层数据结构是什么    
- 为什么不选择二叉树，平衡二叉树，红黑树，B-树   
- hash索引的优缺点，hash冲突了怎么解决（扩展你还知道哪些解决方法呢）   
- 一颗高度为3的B+树可以容纳多少数据   
- 为什么推荐使用递增的数字做索引，使用UUID或者随机数对索引有什么影响    
- mysql8对索引做了哪些改进  
...

## 二叉树    
二叉树是指树中节点度不大于2的有序树，左子树的节点都小于父节点，右子树的节点都大于父节点，这是最简单基础的树结构，其它很多树结构都是由它发展而来。    
假设有2,1,3三个数据，我们依次输入，看看树长什么样子   
![image](1)    

如果我们继续输入4,5，那么会继续在3节点后面添加，最终长这个样子   
![image](2)    

可以看到二叉树并没有"平衡"的能力，最长路径和最短路径可能相差非常大，极端情况下退化成链表，而链表的搜索需要从头找到尾，时间复杂度是O(n)。如图   
![image](3)    

**工具**
算法可视化可以用在线工具 https://www.cs.usfca.edu/~galles/visualization    
屏幕git录制可以下载个GitCam   

## 平衡二叉树     
平衡二叉树顾名思义是平衡的，它的左右两颗子树的高度相差不会超过1，查找时比较的次数不会超过树的高度，这种平衡保证了它可以维持稳定的搜索效率，不会像普通二叉树一样退化为链表。但维持这种平衡需要付出一定的代价，在节点变化时需要旋转树，才能保持平衡。如图：   
![image](4)    

平衡二叉树维持这种绝对平衡，导致插入/删除节点的效率降低，旋转树是需要消耗时间的。   
平衡二叉树的查找效率是O(logn)    

## 红黑树   
红黑树将节点分为红色和黑色两种颜色，通过染色和旋转维持树的平衡，但它不是绝对平衡的，在维持较好搜索效率的情况下，可以减少旋转树的次数，在最好的情况下，红黑树的搜索效率和平衡二叉树是一样的，但减少旋转次数在添加/删除节点时效率更高。   
我们使用相同的数据，如图，可以看到红黑树和平衡二叉树的区别，没那么平衡了但旋转次数也少了，在节点很多的情况下，红黑树依然能保持很好的效率。   
![image](5)    

java的TreeMap内部就使用了红黑树，之前也有过相关介绍，参考[这里]()           
在HashMap发送hash冲突是，当链表节点超过8时，会转换数据结构，使用红黑树存储冲突节点。   

上面介绍的树本质上都是二叉树，随着节点的增加树的高度就增高。    
mysql并没有选择这些树作为索引的数据结构，树的节点存储的是索引数据，假设我们的表有几百上千万的数据，那么树的高度会非常的高。而我们的数据是存储在磁盘的，每次查找都是一次io，显然是无法接受的。   
那么mysql为不把整颗树都加载到内存中呢，这样在内存中查找树也非常快。原因也很简单，内存资源是有限而且宝贵的，一个表可以有多个索引，一个库有很多张表，表的数据可能很多，显然没法把所有索引都load到内存。    

那么如何改造呢？二叉树每个节点只有两个分叉，每个节点只存储一个数据，这导致树的高度很高。改造的目的就是降低树的高度，既然不能增加高度，那么只能增加宽度了。   
假设每个节点可以存储多个数据，每个节点可以有多个分支，那么树就变得“矮胖”了。    

## B-树   
B-树读为"B树"，不是“B减号”，中间的是分隔符，不是减号。    
B树的特点是   
- 非叶子节点存储了指向下一个节点的指针   
- 叶子节点具有相同的深度，叶子节点指针为空   
- 叶子节点和非叶子节点都可以存储数据    
- 每个节点的元素从小到大排序   

我们看一个度为3的B树是如何构建的   
![image](6)    

![image](7)    
如上图，假设要查找15这个数据，需要把根节点加载到内存，然后在内存比较，找到下一个节点的指针，再把下一个节点加载到内存，在内存比较找到数据。   
这里耗时主要是两次io，一次加载根节点，一次加载叶子节点，内存查找的速度是比较快的，几乎可以忽略不计。  
那么是不是一个节点存储的数据越多越好呢？答案是否定的，存储的越多占用内存越高，需要权衡，mysql中一个节点定义为一个页，默认一个页的大小是16k，可以通过 SHOW VARIABLES LIKE 'innodb_page_size'; 查看    
那么为什么是16k呢？怎么不是18k或者32k。    
这个计算机存储原理有关，磁盘和内存打交道的最小单位是4kb，为了减少磁盘io，通常会使用预读加载多一部分数据到内存，这是因为通常读取一个数据有很多的概率会读取它附近的数据，所以每次读取多一些数据到内存，很有可能最近就会使用到，避免频繁的磁盘io，所以一般会读取4kb的整数倍。至于16kb是可以配置的，只不过mysql认为16kb一个页已经足够使用了，下面我们会讲到。   
在linux下，我们创建一个文件只输入一个字符，其大小就是一个字节，但是系统会使用4kb的空间来存储它。    
![image](8)   


那么B树还有没有改进的空间呢？   
仔细看B树的非叶子节点也存储了数据，这导致一页能存储的节点变少了，这会增加了树的高度。极端想一下，如果根节点页只能存储一个元素，其它空间都被数据占用了，那么其它数据就不得不存到下一个层次，如此下去树的高度就会越来越高。      
另外B树对范围查找是非常不友好的，例如我们经常会写如下查询    
select * from t_table where create_time > '2021-12-01' and create_time < '2021-12-17';
select * from t_table where uid in(1,2);

如上图，假设我们3和5两个数据，看看B树是如何找的   
![image](9)   
可以看到B树每次都需要从根节点出发，向下搜索，对于服务查找无疑会有很多次io的损耗。所以在此基础上发展了B+树，mysql索引默认采用的数据结构就是B+树。   

## B+树    
B+树的特点是     
- 叶子节点包含了所有索引数据，也包含了非叶子节点的索引数据   
- 叶子节点可以存储数据，非叶子节点不会存储数据    
- 叶子节点之间通过指针相连，形成链表         

![image](10)    

非叶子节点不存储数据，这样非叶子节点就可以存储更多的索引数据（指针）。   
叶子节点之前通过指针相连，这样范围查找就很方便了，如图我们要找6,7,8三个数据，当找到6后，就会顺着指针找到7,8，如果这三个数据都存储在一个页内，那么在内存中就可以完成，如果跨页，也只需要多一次io，不需要从根节点开始找。   

那么一颗高度为3的B+树到底可以存储多少数据呢？    
假设我们的索引字段是bigint类型，占用8个字节，指向下一个节点的指针mysql分配了6个字节，总共就是14个字节。一个页16kb，可以存储 16 * 1024 / 14 = 1170 个索引数据。   
假设一行数据的大小是1kb，那么一个页可以存储16行数据，那么高度为2的B+大概可以存储 16 * 1170 = 18720 行数据。   
![image](11)   
以此类推，高度为3的树，可以存储 16 * 1170 * 1170 = 21902400 约2千万的数据   
![image](12)   

可以看到使用B+树，2千万的数据树高度大概为3，只需要3次io就可以找到目标数据。另外根节点mysql是永驻内存的，因为根节点比较小，可以存储在内存中，第一步不需要io,在内存中对比根节点即可。   
从这里我们也可以看到，由于B+树的非叶子节点不存储数据，所以它能更多的存储索引数据（指针），这样树的高度会更小。   
按照上面的说法，实际10w数据和千万数据，mysql的查找效率是插不多的，你可以找一个千万数据的表和十万数据的表查询试试，实际两者的效率是接近的。    
上面说的叶子节点存储数据，对于非聚集索引，其存储的是主键，不会存储实际数据，需要数据时需要通过主键再去查一遍，这个过程称为“回表”。因为如果非聚集索引也存储数据的话，那么mysql就需要维护多份数据，需要考虑存储空间和数据一致性问题，这个代价比回表要高得多。   

从上面的分析我们可以得到如下经验   
- 字段设计应合理    
能使用int就不使用bigint，设计合理的字段可以减少存储空间，也有利于每页可以存储更多的索引和数据     
- 主键索引应该是连续有序的    
如果使用UUID作为主键会发生什么，首先空间会占用比较高，导致页存储索引数量变小，io次数会变大。同时由于uuid是随机无序的，可能导致页分裂，同理使用随机数也可能导致页分裂。    

**页分裂**    

**页合并**    

页长什么样子     

























