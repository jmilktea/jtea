## 前言   
索引是类似于目录一样的东西，可以加快查找速度。想象一下，一本几十万字的字典，如果找一个字要一页一页找，无异于大海捞针，而字典的目录可以让我们通过拼音或者偏旁，快速定位到它在哪一页，很快就可以找到，这是我们对索引最直观的理解。在实际开发中很多开发人员也只是根据查询简单的建建索引，只知其一，不理解底层的原理，很难将索引用对用好。另外索引知识也是高级开发必备技能，看下如下连环炮：  
- 索引的优点是什么，缺点是什么        
- 哪些字段适合建索引，为什么推荐使用递增的数字做主键，使用UUID或者随机数对索引有什么问题    
- innodb支持哪些索引结构类型     
- innodb为什么不选择二叉树，平衡二叉树，红黑树，hash，B-树   
- hash索引的优缺点，hash冲突了怎么解决   
- 联合索引最左匹配原则，不最左匹配为什么会生效       
- 一颗高度为3的B+树可以容纳多少数据      
- 索引与锁的关系   
- mysql8对索引做了哪些改进  
...

## 二叉树    
二叉树是指树中节点度不大于2的有序树，左子树的节点都小于父节点，右子树的节点都大于父节点，这是最简单基础的树结构，其它很多树结构都是由它发展而来。    
假设有2,1,3三个数据，我们依次输入，看看树长什么样子   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-1.gif)    

如果我们继续输入4,5，那么会继续在3节点后面添加，最终长这个样子   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-2.png)    

可以看到二叉树并没有"平衡"的能力，最长路径和最短路径可能相差非常大，极端情况下退化成链表，而链表的搜索需要从头找到尾，时间复杂度是O(n)。如图   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-3.png)    

**工具**  
算法可视化可以用在线工具：https://www.cs.usfca.edu/~galles/visualization    
屏幕gif录制工具：GitCam   

## 平衡二叉树     
平衡二叉树顾名思义是平衡的，它的左右两颗子树的高度相差不会超过1，查找时比较的次数不会超过树的高度，这种平衡保证了它可以维持稳定的搜索效率，不会像普通二叉树一样退化为链表。但维持这种平衡需要付出一定的代价，在节点变化时需要旋转树，才能保持平衡。如图：   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-4.gif)    

如果当插入节点后发现左右子树的高度差超过1就会自平衡，为了维持这种绝对平衡，导致插入/删除节点的效率降低，旋转树是需要消耗时间的。   
平衡二叉树的查找效率是O(logn)    

## 红黑树   
红黑树将节点分为红色和黑色两种颜色，通过“染色”和“旋转”维持树的平衡，但它不是绝对平衡的，在维持较好搜索效率的情况下，可以减少旋转树的次数，在最好的情况下，红黑树的搜索效率和平衡二叉树是一样的，但减少旋转次数在添加/删除节点时效率更高。   
我们使用相同的数据，如图，可以看到红黑树和平衡二叉树的区别，没那么平衡了但旋转次数也少了，在节点很多的情况下，红黑树依然能保持很好的效率。   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-5.gif)    

红色树的应用    
在HashMap发送hash冲突是，当链表节点超过8时，会转换数据结构，使用红黑树存储冲突节点。     
java的TreeMap内部就使用了红黑树，之前也有过相关介绍，参考[这里](https://github.com/jmilktea/jmilktea/blob/master/%E7%AE%97%E6%B3%95/%E4%BD%BF%E7%94%A8TreeSet%E4%BC%98%E5%8C%96%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D.md)           

上面介绍的树本质上都是二叉树，随着节点的增加树的高度就增高。    
这些树并不适合作为索引的数据结构，树的节点存储的是索引数据，假设我们的表有几百上千万的数据，那么树的高度会非常的高。而我们的数据是存储在磁盘的，每次查找都是一次io，显然是无法接受的。   
那么为什么不把整颗树都加载到内存中呢，这样在内存中查找树也非常快。原因也很简单，内存资源是有限而且宝贵的，一个表可以有多个索引，一个库有很多张表，表的数据可能很多，显然没法把所有索引都load到内存。    

那么如何改造呢？二叉树每个节点只有两个分叉，每个节点只存储一个数据，这导致树的高度很高。改造的目的就是降低树的高度，既然不能增加高度，那么只能增加宽度了。   
假设每个节点可以存储多个数据，每个节点可以有多个分叉，那么树就变得“矮胖”了。    

## B-树   
B-树读为"B树"，不是“B减号”，中间的是分隔符，不是减号。  
mongodb的索引使用的就是B-树。   
我们先看一个度为3的B树是如何构建的   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-6.gif)  

B树的特点是   
- 非叶子节点存储了指向下一个节点的指针   
- 叶子节点具有相同的深度，叶子节点指针为空   
- 叶子节点和非叶子节点都可以存储数据    
- 每个节点的元素从小到大排序    
  
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-7.png)    
如上图，假设要查找15这个数据，需要把根节点加载到内存，然后在内存比较，找到下一个节点的指针，再把下一个节点加载到内存，在内存比较找到数据。   
这里耗时主要是两次io，一次加载根节点，一次加载叶子节点，内存查找的速度是比较快的，几乎可以忽略不计。  
那么是不是一个节点存储的数据越多越好呢？答案是否定的，存储的越多占用内存越高，需要权衡，mysql中一个节点定义为一个**页**，默认一个页的大小是16k，可以通过 SHOW VARIABLES LIKE 'innodb_page_size'; 查看。那么为什么是16k呢？怎么不是14k或者18k。    

**局部性原理与预读**  
这个计算机存储原理有关，磁盘和内存打交道的最小单位是4kb，为了减少磁盘io，通常会使用预读加载多一部分数据到内存，我们程序很多时候在处理连续的数据，所以读取一个数据很大概率会读取它附近的数据，所以每次读取多一些数据到内存，很有可能最近就会使用到，避免频繁的磁盘io，所以一般会读取4kb的整数倍。操作系统这种读法不怕影响性能吗？影响微乎及微，因为这种读是顺序读，不是随机读，所以是很快的，磁盘不需要再次“寻道”，寻道在整个磁盘io中是最耗时的一个步骤，所以顺序读是很快的，关于顺序读写我们也分析过，[参考这里](https://github.com/jmilktea/jmilktea/blob/master/linux/%E9%A1%BA%E5%BA%8FIO.md)。至于16kb是可以配置的，只不过mysql认为16kb一个页已经足够用，可以存储足够多的数据了，下面我们会讲到。                
在linux下，我们创建一个文件只输入一个字符，其大小就是一个字节，但是系统会使用4kb的空间来存储它。   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-8.png)   

那么B树还有没有改进的空间呢？   
仔细看B树的非叶子节点也存储了数据，这导致一页能存储的节点变少了，这会增加了树的高度。极端想一下，如果根节点页只能存储一个元素，其它空间都被数据占用了，那么其它数据就不得不存到下一个层次，如此下去树的高度就会越来越高。      
另外B树对范围查找是非常不友好的，例如我们经常会写如下查询    
```
select * from t_table where create_time > '2021-12-01' and create_time < '2021-12-17';
select * from t_table where uid in(1,2);
```

如上图，假设我们3和5两个数据，看看B树是如何找的   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-9.gif)   
可以看到B树每次都需要从根节点出发，向下搜索，但此时5就在3的隔壁，对于范围查找无疑会有很多次io的损耗。所以在此基础上发展了B+树，mysql innodb默认索引采用的数据结构就是B+树。   

## B+树    
我们先看一个度为3的B+树是如何构建的   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-10.gif)    

B+树的特点是     
- 叶子节点包含了所有索引数据，也包含了非叶子节点的索引数据   
- 叶子节点可以存储数据，非叶子节点不会存储数据    
- 叶子节点之间通过指针相连，形成链表         
- 每次查找都是稳定的    

非叶子节点不存储数据，这样每个页就可以存储更多的索引数据（指针）。   
叶子节点之前通过指针相连，这样范围查找就很方便了，如图我们要找6,7,8三个数据，当找到6后，就会顺着指针找到7,8，如果这三个数据都存储在一个页内，那么在内存中就可以完成，如果跨页，最多也只需要多一次io，不需要从根节点开始找。   
由于非叶子节点不存储实际数据，所以B+树每次查找都会找到叶子节点，查找次数都是树的高度，而B树可能有的索引查找快，有的索引查找慢，不稳定，可能给人的感觉的就是用索引值1查询快一点，用索引值2查询慢一点。       

那么一个大小为16k的页，一颗高度为3的B+树到底可以存储多少数据呢？    
假设我们的索引字段是bigint类型，占用8个字节，指向下一个节点的指针占用4个字节，总共就是12个字节。一个页16kb，可以存储 16 * 1024 / 12 = 1365 个索引数据。   
假设一行数据的大小是1kb，那么一个页可以存储16行数据，那么高度为2的B+大概可以存储 16 * 1365 = 21840 行数据。   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-11.png)   
以此类推，高度为3的树，可以存储 16 * 1365 * 1365 = 29811600 2千多万的数据   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-12.png)   

可以看到单纯的B+树，2千万的数据树高度大概为3，只需要3次io就可以找到目标数据。    
按照这个说法，实际10w数据和千万数据，mysql的查找效率是差不多的，你可以找十万数据的表和千万数据的表查询试试，实际两者的效率是非常接近的，可能就差一次io。     

mysql索引是在B+树的基础上做了一些优化   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-16.png)    
例如叶子节点是通过双向链表相连的，这样可以保证叶子既可以向前遍历也可以像后遍历。另外为了实现页的管理，mysql页还存储了一些其它信息，如页的校验码、页类型、前/后页节点指针、剩余可用空间等，页结构我们在后面会看到。所以高度为3的mysql B+树，存储的数量是达不到上面的数据量的，但是由于它的非叶子节点不存储数据，所以每增加一层就可以存储n倍的节点，实际我们的数据也可能大于/小于1kb，通常我们认为2千万的数据，mysql B+树的高度大概在3~5之间。    
另外根节点mysql是**常驻内存**的，因为根节点比较小，可以存储在内存中，第一步不需要io,在内存中对比根节点即可。   
上面说的叶子节点存储数据，对于非聚集索引，其存储的是主键，不会存储实际数据，需要数据时需要通过主键再去查一遍，这个过程称为“回表”。因为如果非聚集索引也存储数据的话，那么mysql就需要维护多份数据，需要考虑存储空间和数据一致性问题，这个代价比回表要高得多。   

**从上面的分析我们可以得到如下经验**      
- 字段设计应合理    
能使用int就不使用bigint，设计合理的字段可以减少存储空间，也有利于每页可以存储更多的索引和数据     
- 索引是占据空间的   
mysql要维护索引树，存索引数据，存指针，所以索引不是越多越好      
- 索引字段最好是有序，且不经常修改的    
以聚集索引为例，如果使用递增的字段，那么正好符合B+树的有序性，如果使用的是uuid，那么后面插入的值可能比前面的大，原本一个页已经存满了数据，中间突然需要插入新的一个值，那么不得不挤掉一个数据腾出一个位置，挤出的数据往后找新的位置，这个过程称为“页分裂”。同理，经常修改索引字段也会出现同样的情况。   
- 最左前缀原则     
从B+树的搜索可以看出，每次就是比较一下索引节点找到下一层节点的指针。如果我们的索引字段是字符串，并且不符合最左前缀，那么就没法比较，例如like'%abc'，不知道前面的字符串是多少，要比较只能一个个比，如果走索引也是整个索引一个个比，这种情况就称为“索引扫描”，实际mysql发现这种情况会放弃使用索引，进行全表扫描。   

**主键使用mysql自增还是趋势递增的雪花id好呢**    
上面说到高度为3~5的树大概就能存储2千万数据，对于现在互联网来说2千万已经是个小数据量了，如果数据量继续增加，mysql不得不增加树的高度，从而增加io次数。    
所以考虑到后期分库分表的扩展，通常我们使用雪花id作为主键，避免后面分库分表后出现主键冲突问题。雪花算法生成的id是趋势递增的，那么使用雪花id和mysql自增键有什么区别吗？    
我们知道B+树是有序的，相邻的节点还会通过指针关联，这种有序并不要求按照1,2,3这样的严格递增，只要后面产生的元素比前面的大即可，从这点来说两者不会有什么区别。但是雪花id依赖于时钟，在内存中后生成的id总会比前面的大，但如果生成后迟迟不插入，等到插入时可能已经有很多新的数据产生，这种情况实际影响微乎及微，因为后面产生的数据总是在最后一个节点，就算触发页分裂也只有最后一个页的影响，发生的概率很低，可以忽略不计。当时钟发生回拨时，可能会生成冲突的id，同理对索引存储效率的影响也是极小的，除非回拨到一个很久以前的时间，导致生成的id和现有的id乱序了。    

**联合索引**         
上面讲到的是单值索引，即索引只存储一个索引值，mysql支持联合索引，即一个索引包含多个字段，联合索引也是B+树，也是有序的，存储上如下图    
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-13.png)    
联合索引必须满足最左匹配原则，假设我们建立了索引(c1,c2,c3)，最左匹配原则的意思是必须用到最左的索引字段。    
例如 where c1=10 and c2='abc' and c3='ccc' 或者 where c1 = 10 and c2 = 'abc' 或者 where c1 = 10 and c3 = 'ccc' 这样都是能走索引的。   
但是 where c2 = 'abc' 或者 where c3 = 'ccc' 索引不会生效。    
这是因为联合索引的有序性是按照(c1,c2,c3)字段的顺序来确定的，先按照c1排序，c1相同再按照c2排序，以此类推，所以单看(c1)是有序的，看(c1,c2)也是有序的，但是单看c2是无序的，例如(10,'abc'),(14,'aaa'),数据'aaa' 要小于'abc'，但它排在后面。所以c2='abc'没法快速定位到索引位置。    

联合索引范围查询右边失效     
上面是等值查询，当遇到范围查询，第一个范围查询后面的字段不会用到索引。   
例如 where c1 > 5 and c2 = 'abc'，符合最左匹配原则，可以使用到(c1,c2,c3)索引，但由于c1使用了范围查询，大于5的索引数据中c2是无序的，此时无法快速查找到'abc'，mysql不会再在索引中查找比较数据了，而是开始回表查找需要的数据后，再在内存中逐个过滤，相比等值查询，这种情况的效率会有所下降。        

## hash索引      
hash算法的时间复杂度是O(1)，通过hash(索引字段)一次即可定位到具体磁盘位置，只需要一次io，并且不会随着数据量的增加而变慢，当出现hash冲突时，使用链表存储冲突元素。memory存储引擎默认支持的就是hash索引，innodb不支持。   
hash索引这么快，为什么innodb不支持呢，因为hash索引只支持精确查询，对范围查找就无能为力了，或者像like 'abc%'这样的最左前缀查找也支持不了。   

## FULLTEXT/SPATIAL   
innodb的索引默认是B+树，也支持FULLTEXT/SPATIAL索引。  
FULLTEXT全文索引，用于支持全文搜索，我们知道B+树索引必须符合最左前缀原则，否则会退化为索引扫描，而模糊搜索也是常见的需求，全文索引用于支持like'%abc%'这样的查询。   
SPATIAL空间索引，用于空间字段的搜索。      

## mysql8索引改进    
- 隐藏索引   
mysql8提供了的索引的invisible/visible，mysql依然会对隐藏索引进行索引树的维护，但优化器在选择的时候会过滤掉不可见的索引，这可以实现索引的灰度发布和测试。    
例如现在要删除一个大表的索引，如果直接drop index，发现还有许多查询使用到这个索引，是没法回滚的，而不得不重新create index，大表建索引要建索引树又是很慢的。而隐藏索引的做法是先将所有设置为invisible，此时优化器不会使用该索引，如果发现还有查询使用到（例如慢日志，告警等），可以快速重置为visible，如果没有就放心的drop掉。    
- 函数索引    
支持使用函数计算索引数据的值，如 add index idx_create_time(func(create_time))，func可以是系统函数也可以是自定义函数。   
函数索引并没有什么魔法，底层使用的还是B+树，只不过会先计算一下索引值再存储而已。   
这个场景是由于如果在查询时再使用函数进行计算，mysql是不会使用索引的，所以提供了一种逆向思路，存储的时候就给你计算好。   
- 降序索引    
mysql8.0以前已经为索引预留了asc,desc语法，但实际没有提供实现，等到8.0才真正实现。    
```
ALTER TABLE table1 ADD INDEX idx_test(c1 ASC,c2 DESC);
```    
对于单个索引来说，升序降序并没有意义，本身升序也支持降序读，只不过指针从后往前挪即可。    
对于联合索引在排序的时候就有作用了，例如   
```
select * from table1 order by c1,c2 desc;
```
在8.0以前由于都是升序索引，(c1,c2)整体是升序的，但有时候我们需要按照c2降序排列，这个时候索引顺序已经不能支持，mysql不得不通过filesort来实现。    
在8.0可以建立(c1,c2 desc)索引，这样在存储的时候c2就是降序的，索引顺序就是order by顺序，filesort消除。   

## 索引与锁     
mysql在进行dml的时候，需要对数据进行加锁，保证数据的安全性，具体加锁的对象就是索引。    
如果是主键，则直接对主键进行加锁，如果是二级索引，就先对二级索引进行加锁，再根据主键值找到主键的位置，对主键进行加锁。   
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-15.png)    

对主键索引进行加锁实际就已经锁住了整行数据，那为什么还需要锁二级索引呢？    
因为索引本身也是可以修改的，如我们可以执行 
```
update table1 set c3 = 'abc' where c1 = 10 and c2 = 'abc' and c3 = 'ccc';
```   
如果不对二级索引进行加锁，二级索引就会有并发问题。那能不能只对二级索引进行加锁，也是不够的，如   
```
update table1 set c4 = 1 where c1 = 10 and c2 = 'abc' and c3 = 'ccc';   
update table1 set c4 = 1 where id = 1;  
```
可以根据不同的条件修改字段，不一定都是根据同一个索引。   
由于这种多级加锁，就可能发生死锁。例如主键是id，有C1(c1),C2(c2)两个索引，执行语句       
```
update c3 = 1 where c1 = 1;   
update c1 = 1 where c2 = 2;   
```
前者加锁(c1,id),后者加锁(c2,id)，同时修改c1索引字段，需要等待c1上的锁，这样就可能出现前者获取到c1锁，等到主键锁，后者获取到主键锁，等待c1锁，造成死锁。    

## 页结构     
![image](https://github.com/jmilktea/jmilktea/blob/master/mysql/images/index-17.png)     
File Header，保存也页级别的一些信息，如FIL_PAGE_PRE,FIL_PAGE_NEXT分别指向上一个页和下一个页的指针。       
Page Header，保存了页内的一些信息，如页中第一个记录的地址，页中的记录数量等。    
User Records，保存的是数据行记录，是我们实际数据的存储位置。      

**页分裂/页合并**     
当页存储不下数据，或者页内的数据需要移动时，就会发生页分裂，例如当前页已经满了，存不下新的数据，mysql就会创建新的页来容纳新的数据，同样的如果位置改变也可能会导致页分裂，这个过程是有性能损耗的。    
当我们delete一行数据时，实际并不会从页的User Records将这行数据物理删掉，而是逻辑标记为删除，这样会产生许多物理碎片，页的利用率会下降。实际上当数据被标记为删除后，它的空间是可以被复用的，例如有1,3,5三行数据，执行   
```
delete from table1 where id = 3;
insert into table1(id) values(4);
```
后面插入的4会复用3的物理空间，此时3才真正消失了。那么如果标记删除后一直没有插入呢？例如一个页16行数据，15行都被标记为删除了，此时就会触发页合并。  
页合并有一个重要的参数MERGE_THRESHOLD，表示当利用率达到多少时，就触发页合并，默认为50，例如我们可以为索引设置MERGE_THRESHOLD为40    
```
ALTER TABLE account ADD INDEX idx_test(user_id) COMMENT 'MERGE_THRESHOLD=40';
SHOW INDEX FROM account; -- Index_comment MERGE_THRESHOLD=40
```
当发现达到合并阀值后，mysql会寻找最靠近可以合并的页，将两个页合并在一起，形成一个新的页，另外一个页可以复用。   

























