- 为什么是三次握手，而不是两次或者四次   
- 什么是CLOSE_WAIT,TIME_WAIT        
- 为什么TIME_WAIT要等2MSL才能close      
- 什么是半连接/全连接队列   

tcp(传输控制协议)协议字段和三次握手和四次挥手的过程如下   
![image](1)    
![image](2)     

**三次握手**    
开始server处于LISTEN监听状态，等待客户端连接的到来    
客户端开始第一次握手，SYN=1,seq=x，SYN和seq都是tcp报文的一部分，SYN表示建立请求标志位，seq是报文的序号   
服务端收到请求，开始第二次握手，SYN=1,ACK=1表示确认建立链接，ack等于客户端请求seq+1，表示确认该次请求   
客户端收到请求后，开始第三次握手，ACK=1表示确认建立链接，ack等于服务端请求seq+1，表示确认该次请求，客户端进入ESTABLISHED已确认建立链接状态   
服务端收到请求后，进入ESTABLISHED已确认建立链接状态       

建立链接后，双方可以开始通信，收发数据。当数据传输完成后，开始四次挥手断开链接。   

**四次挥手**    
客户端开始第一次挥手，发送FIN=1,seq=u，FIN表示链接结束标志位，同样会带一个报文序号。客户端发送后进入FIN_WAIT_1状态    
服务端收到请求后，开始第二次挥手，ACK=1,ack=u+1对应上一次挥手，表示我知道要断开了，服务端进入CLOSE_WAIT状态，服务端进入该状态而不是立马断开，需要等上层应用来close，可能上层应用还有数据在处理中，所以不能立马断开。客户端收到该挥手后进入FIN_WAIT_2状态。      
服务端等到上层应用处理完成后，开始第三次挥手FIN=1,ACK=1,seq=w,ack=u+1，表示可以正式断开了，进入LAST_ACK等客户端最后确认。   
客户端收到服务端可以断开通知后，开始第四次挥手，ACK=1,seq=u+1,ack=w+1，表示确认正式断开，服务端后端这次请求后就正式进入close状态，而客户端进入TIME_WAIT状态，等到2MSL时间后，再进入close状态，此时链接完全关闭。    

回到最开始面试常问的几个问题   
- 为什么不是两次或者四次，而是三次握手    
tcp是可靠的传输，对于建立链接来说，可靠的前提就是双方都能确保收发正常，自己收发正常并且知道对方收发正常。   
**第一次握手**   
客户端什么都不能确认，服务端可以确认对方发送正常   
**第二次握手**    
客户端可以确认自己发送/接收正常，对方发送/接收正常   
服务端可以确认自己接收正常，对方发送正常    
**第三次握手**   
客户端可以确认自己发送/接收正常，对方发送/接收正常   
服务端可以确认自己发送/接收正常，对方发送/接收正常    

- CLOSE_WAIT/TIME_WAIT    
CLOSE_WAIT是四次挥手中，服务端收到断开请求后，两次挥手回复客户端之间的状态，之所以需要这个状态，是因为服务端在收到断开请求后，需要等待已接受的请求处理完。TIME_WAIT是客户端在第四次挥手后，进入一个2MSL等待时间的状态，等到这个时间过后，会进入close状态。  

- 为什么TIME_WAIT要等2MSL才close    
首先MSL指的是一个tcp报文在网络上的最大存活时间。   
按道理来说，发送完最后一个ACK后，就可以进入close状态了。但是网络是不可靠的，最后一个ACK可能会丢失，所以TIME_WAIT状态就是防止最后一个ACK丢失，用来重发可能丢失的报文。假设最后一个ACK丢失了，服务端没有收到确认回复，将会不断重复发送FIN，所以客户端不能立刻关闭，因为可能还会收到服务端重发的FIN。那么为什么是2MSL呢？2MSL其实就是一个来回所需要的最大时间，如果这个时间内没有收到服务端重发了FIN，客户端就可以确认服务端是收到了,可以close。   

- 半连接/全连接队列    
服务端第一次收到客户端握手后，就进入SYN_RCVD状态，此时链接还未正式建立，系统会把它放在一个半连接队列。等到三次握手成功后就会放到一个全连接队列。   


参考：
[朋友阿里面试题之 TCP/IP，回去等通知吧](https://www.bilibili.com/read/cv8702424])




